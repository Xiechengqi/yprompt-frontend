const x=Math.PI,y=2*x,u=1e-6,m=y-u;function P(e){this._+=e[0];for(let t=1,s=e.length;t<s;++t)this._+=arguments[t]+e[t]}function A(e){let t=Math.floor(e);if(!(t>=0))throw new Error(`invalid digits: ${e}`);if(t>15)return P;const s=10**t;return function(i){this._+=i[0];for(let h=1,n=i.length;h<n;++h)this._+=Math.round(arguments[h]*s)/s+i[h]}}class d{constructor(t){this._x0=this._y0=this._x1=this._y1=null,this._="",this._append=t==null?P:A(t)}moveTo(t,s){this._append`M${this._x0=this._x1=+t},${this._y0=this._y1=+s}`}closePath(){this._x1!==null&&(this._x1=this._x0,this._y1=this._y0,this._append`Z`)}lineTo(t,s){this._append`L${this._x1=+t},${this._y1=+s}`}quadraticCurveTo(t,s,i,h){this._append`Q${+t},${+s},${this._x1=+i},${this._y1=+h}`}bezierCurveTo(t,s,i,h,n,$){this._append`C${+t},${+s},${+i},${+h},${this._x1=+n},${this._y1=+$}`}arcTo(t,s,i,h,n){if(t=+t,s=+s,i=+i,h=+h,n=+n,n<0)throw new Error(`negative radius: ${n}`);let $=this._x1,r=this._y1,p=i-t,o=h-s,a=$-t,l=r-s,_=a*a+l*l;if(this._x1===null)this._append`M${this._x1=t},${this._y1=s}`;else if(_>u)if(!(Math.abs(l*p-o*a)>u)||!n)this._append`L${this._x1=t},${this._y1=s}`;else{let f=i-$,c=h-r,w=p*p+o*o,T=f*f+c*c,g=Math.sqrt(w),v=Math.sqrt(_),b=n*Math.tan((x-Math.acos((w+_-T)/(2*g*v)))/2),M=b/v,E=b/g;Math.abs(M-1)>u&&this._append`L${t+M*a},${s+M*l}`,this._append`A${n},${n},0,0,${+(l*f>a*c)},${this._x1=t+E*p},${this._y1=s+E*o}`}}arc(t,s,i,h,n,$){if(t=+t,s=+s,i=+i,$=!!$,i<0)throw new Error(`negative radius: ${i}`);let r=i*Math.cos(h),p=i*Math.sin(h),o=t+r,a=s+p,l=1^$,_=$?h-n:n-h;this._x1===null?this._append`M${o},${a}`:(Math.abs(this._x1-o)>u||Math.abs(this._y1-a)>u)&&this._append`L${o},${a}`,i&&(_<0&&(_=_%y+y),_>m?this._append`A${i},${i},0,1,${l},${t-r},${s-p}A${i},${i},0,1,${l},${this._x1=o},${this._y1=a}`:_>u&&this._append`A${i},${i},0,${+(_>=x)},${l},${this._x1=t+i*Math.cos(n)},${this._y1=s+i*Math.sin(n)}`)}rect(t,s,i,h){this._append`M${this._x0=this._x1=+t},${this._y0=this._y1=+s}h${i=+i}v${+h}h${-i}Z`}toString(){return this._}}function L(){return new d}L.prototype=d.prototype;function q(e=3){return new d(+e)}function C(e){return function(){return e}}function R(e){let t=3;return e.digits=function(s){if(!arguments.length)return t;if(s==null)t=null;else{const i=Math.floor(s);if(!(i>=0))throw new RangeError(`invalid digits: ${s}`);t=i}return e},()=>new d(t)}export{d as P,q as a,C as c,L as p,R as w};
